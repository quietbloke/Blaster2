<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Micro Invasion</title>
<style>
Body{background-color:#282828;color:#ffffff;margin:0px;}
Canvas{position:fixed;background-color:black;}
#counter{position:absolute; bottom:0;right:0;color:#ffffff;display:hidden;}
#debug{position:absolute; bottom:0;left:0;color:#ffffff;display:hidden;}
</style>
</head>
<body>
	<canvas id="myCanvas">Sorry... your browser does not support the canvas element.</canvas>
	<p id="counter">counter</p>
	<p id="debug">debug</p>
</body>
<script>
// Global variables
// used for calculating and showing the frames per second
var dwFrames=0;
var dwCurrentTime=0;
var dwLastUpdateTime=0;
var dwElapsedTime=0;
var fpsText;

var keystate = new Array();

var canvas;
var ctx;

var audio = new Array();

// browser stuff
function doResize()
{
	var canvas = document.getElementById('myCanvas');
	var scrH = window.innerHeight;
	var scrW = window.innerWidth;

	var ratioX = 256 / scrW;
	var ratioY = 144 / scrH;

	var ratio = Math.max(ratioX,ratioY);
		
	var width = 256 / ratio;
	var height = 144 / ratio;

	canvas.style.height = height+"px";
	canvas.style.width = width+"px";
	canvas.style.marginLeft = (scrW-width)/2;
	canvas.style.marginTop = (scrH-height)/2;
}

const screenWidth = 1280;
const screenHeight = 768;
const gameWidth = screenWidth * 2;
const gameHeight = screenHeight;
const gameXMax  =  gameWidth/2;
const gameXMin  =  -gameXMax;
const gameYMax  =  gameHeight/2;
const gameYMin  =  -gameYMax;

const LAYER_PLAYER = 1;
const LAYER_ENEMY = 2;
const LAYER_POWER_UP = 4;
const LAYER_PLAYER_SHOT = 8;
const LAYER_ENEMY_SHOT = 16;
const LAYER_HUD = 32;
const LAYER_LAST_LAYER = 32;

const PREFAB_PLAYERS = 0;
const PREFAB_PARTICLES = 1;
const PREFAB_PLAYERSHOTS = 2;
const PREFAB_ENEMYA = 3;
const PREFAB_ENEMYB = 4;
const PREFAB_POWERUPS = 5;
const PREFAB_RADARHUD = 6;
const PREFAB_SPAWNER = 7;
const PREFAB_LAST = 7;

const FPS = 50;

var entities = {};	// Entities exists in layers
var systems = {};

var shipData = [["M",-20,-10],["L",20,0],["L",-20,10],["L",-20,-10] ];
var enemyData = [["M",-10,-10],["L",10,-10],["L",10,10],["L",-10,10],["L",-10,-10] ];
var powerUpData = [["M",-5,-5],["L",5,5],["M",5,-5],["L",-5,5]];
var explosionData = [["M",-1,-1],["L",1,-1],["L",1,1],["L",-1,1],["L",-1,-1] ];
var playerShotData = [["M",-6,-1],["L",6,-1],["L",6,1],["L",-6,1],["L",-6,-1] ];
var radarBorderData = [["M", gameXMin / 10 - 2, -screenHeight / 10 / 2 - 3], 	
	["L", gameXMin / 10-2, screenHeight/10/2 + 3],
	["L", gameXMax / 10+2, screenHeight/10/2 + 3],
	["L", gameXMax / 10+2, -screenHeight/10/2 - 3],
	["L", gameXMin / 10-2, -screenHeight/10/2 - 3]];

var prefabs = PrefabManager();

var previousTime = (new Date).getTime();
var timerElasped = 0;
var timerOverflow = 0;
var expectedTimeSpan = Math.floor(1000/FPS);

init = function()
{
	if ( typeof(localStorage != "undefined"))
		hiscore = localStorage.getItem("highscore");

	canvas = document.getElementById('myCanvas');
	if (canvas.getContext)
	{
		canvas.width = screenWidth;
		canvas.height = screenHeight;

		// when the window resizes we want to resize the canvas
		window.onresize = function() { doResize(); };
		doResize();

		BuildSounds();

		document.addEventListener("keydown", function (e) { keystate[e.keyCode] = 1;} );
		document.addEventListener("keyup", function (e) { keystate[e.keyCode] = 0; });	

		// set timer to game main function
		ctx = canvas.getContext('2d');

		ctx.translate(screenWidth/2, screenHeight/2);
		
		entities = QuickCollection();
		for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
		{
			entities[layer] = QuickCollection();
		}
		
		prefabs.CreatePlayer(37,39,38,90);

		prefabs.CreateSpawner(-screenWidth/2+50,0,10,"EnemyA");
		prefabs.CreateSpawner(screenWidth/2-50,0,10, "EnemyB");
		
		prefabs.CreateRadarHud();
		
		timerId = setInterval ( main, Math.floor(1000/FPS));
	}
}

main = function ()
{
	// fps code .... this can go when we are done
	dwFrames++;
	dwCurrentTime = (new Date).getTime();
	dwElapsedTime = dwCurrentTime - dwLastUpdateTime;
	if(dwElapsedTime >= 1000)
	{        
		fpsText = "FPS " + dwFrames;
		dwLastUpdateTime = dwCurrentTime;
		dwFrames = 0;
	}
	var l = document.getElementById('counter');
	l.textContent = fpsText;
	// end of fps code
	
	// Time since we were last called
	timeElapsed = dwCurrentTime - previousTime + timerOverflow;
	
	// figure out how many update frames we should do 
	var updates = Math.floor(timeElapsed / expectedTimeSpan );
	previousTime = dwCurrentTime;

	timerOverflow = timeElapsed - (updates * expectedTimeSpan);
	
	// if the machine really cant handle it then 
	// give up and show then a slowed down game
	if ( updates > 4 ) 
	{
		updates = 4;
		timerOverflow = 0;
		console.log("Max frame updates exceeded");
	}
	
	for ( var l = 0; l < updates; l++)
	{
		SysCollisions();
		SysPhysics();
		SysPlayer();
		SysEnemies();
		SysCamera();
		SysDestroyer();
	}
	
	
	// and finally do a render
	ctx.globalAlpha = 0.75;
	ctx.fillRect(-screenWidth/2, -screenHeight/2, screenWidth, screenHeight);
	ctx.globalAlpha = 1;

	SysRender();
}

var nextId = 0;
// An entity is just a unique id and contains a collection of components
Entity = function()
{
	var obj = {};
	obj.components = new Array();
	obj.ID = nextId;
	nextId++;
	
	obj.AddComponent= function ( component )
	{
		obj.components[component.Name] = component;
	}
	
	obj.DeleteComponent= function ( componentName )
	{
		delete obj.components[componentName];
	}
	
	return obj;
}

// components have a name and can contain a block of data
// For the moment all components are prefixed with Comp

const COMP_POSITION = 0;
const COMP_ROTATION = 1;
const COMP_VISIBLE = 2;
const COMP_PHYSICS = 3;
const COMP_PLAYER = 4;
const COMP_LIFESPAN = 5;
const COMP_SCREENWRAP = 6;
const COMP_SCREENBOUNCE = 7;
const COMP_ENEMYA = 8;
const COMP_ENEMYB = 9;
const COMP_POWERUP = 10;
const COMP_PREFAB = 11;
const COMP_CAMERA = 12;
const COMP_GAMEPOS = 13;
const COMP_RADAR = 14;
const COMP_COLLIDE = 15;
const COMP_SPAWNER = 16;

CompPosition = function (xpos, ypos)
{
	return {"Name" : "Position", 
		"Position" : new Vector(xpos,ypos)};
}

CompRotation = function (rotation)
{
	return {"Name" : "Rotation", 
		"Rotation" : rotation,
		"Rotatespeed" : 0};
}

CompVisible = function (drawData,colour,layer)
{
	// given the data calculate the bounding box
	var topleft = Vector(0,0);
	var bottomright = Vector(0,0);

	return {"Name" : "Visible", 
		"Drawdata" : drawData,
		"Colour" : colour,
		"Layer" : layer,
		"Topleft" : topleft,
		"Bottomright" : bottomright};
}

CompPhysics = function (xvel, yvel, acceleration, drag, maxvelocity)
{
	return {"Name" : "Physics", 
		"Velocity" : new Vector(xvel,yvel), 
		"Acceleration" : acceleration, 
		"Drag" : drag,
		"Maxvelocity" : maxvelocity};
}

CompPlayer = function ( leftkey, rightkey, acceleratekey, shootkey)
{
	return {"Name" : "Player", 
		"KeyLeft" : leftkey, 
		"KeyRight" : rightkey, 
		"KeyAccelerate" : acceleratekey,
		"KeyShoot" : shootkey,
		"ShotRate" : 10,
		"ShotElapsedTime" : 0,
		"Rotaterate" : Math.PI/40 };
}

CompLifeSpan = function ( maxAge )
{
	return {"Name" : "Lifespan", 
		"MaxAge" : maxAge, 
		"Age" : 0 };
}

CompScreenWrap = function ()
{
	return {"Name" : "Screenwrap" };
}

CompScreenBounce = function ()
{
	return {"Name" : "Screenbounce" };
}

CompEnemyA = function ()
{
	return {"Name" : "EnemyA" };
}

CompEnemyB = function ()
{
	return {"Name" : "EnemyB" };
}

CompPowerUp = function ()
{
	return {"Name" : "PowerUp" };
}

CompPrefab = function (type, pos)
{
	return {"Name" : "Prefab", "Type" : type, "Position" : pos };
}

CompPlayerShot = function ()
{
	return {"Name" : "PlayerShot"};
}

CompCamera = function ()
{
	return {"Name" : "Camera"};
}

CompGamePos = function ()
{
	return {"Name" : "Gamepos"};
}

CompRadar = function ()
{
	return {"Name" : "Radar"};
}

CompCollide = function (collisionLayers)
{
	return {"Name" : "Collide",
		"Collisionlayers" : collisionLayers, 
		"Collided" : false,
		"Destroy" : false};
}

CompSpawner = function(xpos,ypos,spawnRate, prefabType)
{
	return {"Name" : "Spawner",
		"SpawnRate" : spawnRate, 
		"SpawnPrefab" : prefabType,
		"ElapsedTime" : 0};
}

// Systems will perform actions on any entities that contains all the 
// components they require.
// For the moment all Systems are prefixed with Sys
SysRender = function()
{
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Position && e.components.Visible)
			{
				var pos = e.components.Position.Position;
				var data = e.components.Visible.Drawdata;
				var rotated = data;
				if ( e.components.Rotation)
				{
					var rotate = e.components.Rotation.Rotation;

					rotated = [];
					for ( var pIdx = 0; pIdx < data.length; pIdx++)
					{
						var p = data[pIdx];
						newX = p[1] * Math.cos(rotate) - p[2] * Math.sin(rotate);
						newY = p[1] * Math.sin(rotate) + p[2] * Math.cos(rotate);

						rotated[pIdx] = [p[0],newX, newY];
					}
				}
				// Don't know if this is the place to do this but
				// as we have now rotated and are about to draw
				// we can recalculate the bounding box
				var topleft = e.components.Visible.Topleft;
				var bottomright = e.components.Visible.Bottomright;
				topleft.x = 0;
				topleft.y = 0;
				bottomright.x = 0;
				bottomright.y = 0;

				for ( var pIdx = 0; pIdx < rotated.length; pIdx++)
				{
					var p = rotated[pIdx];
					if ( p[1] < topleft.x)
						topleft.x = p[1];
					if ( p[1] > bottomright.x)
						bottomright.x = p[1];
					if ( p[2] < topleft.y)
						topleft.y = p[2];
					if ( p[2] > bottomright.y)
						bottomright.y = p[2];
				}
				topleft.x += 2;
				topleft.y += 2;
				bottomright.x -= 2;
				bottomright.y -= 2;

				// now draw the shape
				if ( pos.x + bottomright.x > -screenWidth/2 || pos.x + topleft.x < screenWidth/2)
				{
					ctx.beginPath();
					
					var scrX = pos.x;
					var scrY = pos.y;
				
					for ( var pIdx = 0; pIdx < rotated.length; pIdx++)
					{
						var p = rotated[pIdx];
						scrX = pos.x + p[1];
						scrY = pos.y + p[2];
						if ( p[0] == 'M')
						{
							ctx.moveTo(scrX,scrY);
						}
						else
						{
							ctx.lineTo(scrX,scrY);
						}
					}
					ctx.strokeStyle=e.components.Visible.Colour;
					ctx.stroke();
				}
				// and draw the radar version
				if ( e.components.Radar )
				{
					ctx.beginPath();
					scrX = pos.x / 10;
					scrY = pos.y / 10 - screenHeight/2 + gameHeight/10/2;
					ctx.moveTo(scrX-2,scrY-2);
					ctx.lineTo(scrX+2,scrY-2);
					ctx.lineTo(scrX+2,scrY+2);
					ctx.lineTo(scrX-2,scrY+2);
					ctx.lineTo(scrX-2,scrY-2);
					ctx.strokeStyle=e.components.Visible.Colour;
					ctx.stroke();
				}
				
				// For debug puposes we will draw the bounding box
	//			var topleft = e.components.Visible.Topleft;
	//			var bottomright = e.components.Visible.Bottomright;
	//			ctx.beginPath();
	//			ctx.moveTo(pos.x + topleft.x, pos.y + topleft.y);
	//			ctx.lineTo(pos.x + bottomright.x, pos.y + topleft.y);
	//			ctx.lineTo(pos.x + bottomright.x, pos.y + bottomright.y);
	//			ctx.lineTo(pos.x + topleft.x, pos.y + bottomright.y);
	//			ctx.lineTo(pos.x + topleft.x, pos.y + topleft.y);
	//			ctx.strokeStyle="darkred";
	//			ctx.stroke();
			}
		}
	}
}

SysCollisions = function()
{
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Position && e.components.Visible && e.components.Collide)
			{
				var topleft = e.components.Visible.Topleft;
				var bottomright = e.components.Visible.Bottomright;
				var pos = e.components.Position.Position;

				for ( var layer2 = 0; layer2 <= LAYER_LAST_LAYER; layer2 == 0 ? layer2 = 1 : layer2 = layer2 << 1)
				{
					if ( layer2 & e.components.Collide.Collisionlayers )
					{
						for ( var eIdx2=entities[layer2].length-1; eIdx2 >= 0; eIdx2--)
						{
							var e2 = entities[layer2].data[eIdx2];
							if (e2 && e2.components.Position && e2.components.Visible && e2.components.Collide ) 
							{
								var topleft2 = e2.components.Visible.Topleft;
								var bottomright2 = e2.components.Visible.Bottomright;
								var pos2 = e2.components.Position.Position;
								// see if this other entity has collided with us
								// Note this is all terribly inneficient but is 
								// ok for a small amount of sprites

								if ( pos.x + topleft.x < pos2.x + bottomright2.x
									&& pos.x + bottomright.x > pos2.x + topleft2.x
									&& pos.y + topleft.x < pos2.y + bottomright2.y
									&& pos.y + bottomright.y > pos2.y + topleft2.y)
								{
									e.components.Collide.Collided = true;
								}
							}
						}
					}
				}
			}
		}
	}
}

SysCamera = function()
{
	var cameraPosX;
	var cameraPosY;
	// find first camera entity with a position
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Camera && e.components.Position && e.components.Physics)
			{
				cameraPosX = e.components.Position.Position.x + e.components.Physics.Velocity.x * 50;
				cameraPosY = 0;
			}
		}
	}
	
	if ( cameraPosX == null)
		return;
		
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Gamepos && e.components.Position)
			{
				var pos = e.components.Position.Position;
				
				pos.x = pos.x - cameraPosX;
				pos.y = pos.y - cameraPosY;
			}
		}
	}
}

SysPhysics = function()
{
	var cameraPosX = 0;
	var cameraPosY = 0;
	// find first camera entity with a position
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Camera && e.components.Position)
			{
				cameraPosX = e.components.Position.Position.x;
				cameraPosY = e.components.Position.Position.y;
			}
		}
	}
	
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Position && e.components.Physics)
			{
				var pos = e.components.Position.Position;
				var physics = e.components.Physics;
				var vel = physics.Velocity;
				
				if ( e.components.Rotation )
				{
					var rotation = e.components.Rotation.Rotation;
					rotation += e.components.Rotation.Rotatespeed;
					e.components.Rotation.Rotation = rotation;
				}

				
				pos.x = pos.x + vel.x;
				pos.y = pos.y + vel.y;
				
				// Apply the drag
				vel.x *= physics.Drag;
				vel.y *= physics.Drag;

				// limit to max velocity
				if ( physics.Maxvelocity)
				{
					if (vel.Magnitude() > physics.Maxvelocity )
					{
						vel.SetMagnitude(physics.Maxvelocity);
					}
				}

				if (e.components.Screenwrap)
				{
					HandleScreenWrap(pos);
				}

				if (e.components.Screenbounce)
				{
					HandleScreenBounce(pos,vel);
				}
			}
		}
	}
	
	function HandleScreenWrap(pos)
	{
		if ( pos.x <= gameXMin )
			pos.x += gameWidth;

		if ( pos.x >= gameXMax-1 )
			pos.x -= gameWidth;

		if ( pos.y <= gameYMin )
			pos.y += gameHeight;

		if ( pos.y >= gameYMax-1 )
			pos.y -= gameHeight;
	}
	
	function HandleScreenBounce(pos, vel)
	{
		if ( pos.x <= gameXMin ) 
		{
			if ( vel.x < 0 )
			{
				vel.x = -vel.x;
			}
			pos.x = gameXMin;
		}

		if ( pos.x >= gameXMax-1 ) 
		{
			if ( vel.x > 0  )
			{
				vel.x = -vel.x;
			}
			pos.x = gameXMax-1;
		}

		if ( pos.y <= gameYMin ) 
		{
			if ( vel.y < 0 )
			{
				vel.y = -vel.y;
			}
			pos.y = gameYMin;
		}

		if ( pos.y >= gameYMax-1 ) 
		{
			if ( vel.y > 0)
			{
				vel.y = -vel.y;
			}
			pos.y = gameYMax-1;
		}
	}
}

SysEnemies = function()
{
	for ( var eIdx=entities[LAYER_ENEMY].length-1; eIdx >= 0; eIdx--)
	{
		var e = entities[LAYER_ENEMY].data[eIdx];
		if (e && ( e.components.EnemyA || e.components.EnemyB ) )
		{
			CheckCollided(e);
		}

		if ( e.components.Spawner)
		{
			var spawner = e.components.Spawner;
			spawner.ElapsedTime++;
			if ( prefabs.Count(spawner.SpawnPrefabType) < 150)
			{
				if ( spawner.ElapsedTime > spawner.SpawnRate)
				{
					var xpos = 0;
					var ypos = 0;
					if (e.components.Position)
					{
						xpos = e.components.Position.Position.x;
						ypos = e.components.Position.Position.y;
					}
					spawner.ElapsedTime = 0;
					if ( spawner.SpawnPrefabType == "EnemyA")
						prefabs.CreateEnemyA(xpos,ypos);
					if ( spawner.SpawnPrefabType == "EnemyB")
						prefabs.CreateEnemyB(xpos,ypos);
				}
			}
		}
	}
	// find the player
	var playerEntity = null;
	for ( var eIdx=0; eIdx < entities[LAYER_PLAYER].length; eIdx++)
	{
		var e = entities[LAYER_PLAYER].data[eIdx];
		if (e && e.components.Player && e.components.Position )
		{
			playerEntity = e;
			break;
		}
	}
	
	// drift the powerup towards the player
	for ( var eIdx=entities[LAYER_POWER_UP].length-1; eIdx >= 0; eIdx--)
	{
		var e = entities[LAYER_POWER_UP].data[eIdx];
		if ( e.components.PowerUp && e.components.Position && e.components.Physics )
		{
			// very basic just move towards player slowly
			if ( e.components.Physics && playerEntity )
			{
				var physics = e.components.Physics;
				var vel = physics.Velocity;
				
				var playerPos = playerEntity.components.Position.Position;
				var enemyPos = e.components.Position.Position;
				
				var xlen = playerPos.x - enemyPos.x;
				var ylen = playerPos.y - enemyPos.y;
				var vec = Vector(xlen,ylen);
				
				var distance = vec.Magnitude();
				
				if ( distance < 300)
				{
					var accel = (300-distance) / 150;
					accel *= accel;
					vec.SetMagnitude(accel);

					vel.x += vec.x;
					vel.y += vec.y;
//					vel.Add(vec);
				}
				
//				if ( playerPos.x < enemyPos.x )
//					vel.x = -.5;
//				if ( playerPos.x > enemyPos.x )
//					vel.x = .5;
//				if ( playerPos.y < enemyPos.y )
//					vel.y = -.5;
//				if ( playerPos.y > enemyPos.y )
//					vel.y = .5;
			}
		}

		if (e && e.components.PowerUp && e.components.Collide && e.components.Collide.Destroy == false)
		{
			if ( e.components.Collide.Collided)
			{
				e.components.Collide.Destroy = true;
				PlaySound(1);
			}
		}
	}

	function CheckCollided ( e)
	{
		if ( e.components.Collide)
		{
			if ( e.components.Collide.Collided)
			{
				e.components.Collide.Destroy = true;
				if ( e.components.Position && e.components.Visible)
					CreateExplosion(e.components.Position.Position, e.components.Visible.Colour);
				if ( e.components.Position )
					prefabs.CreatePowerUp(e.components.Position.Position.x,e.components.Position.Position.y,0,0);
				PlaySound(2);
			}
		}
	}
	
	function CreateExplosion(pos, colour)
	{
		for ( var p = 0; p < 50; p++)
		{
			var angle = Math.random() * Math.PI * 2;
			var speed = Math.random() * .3 + 2;
			var xvel = speed * Math.sin(angle);
			var yvel = speed * Math.cos(angle);
		
//			prefabs.CreateParticle(pos.x,pos.y,(Math.random()-.5)*2,(Math.random()-.5)*2,colour);
			prefabs.CreateParticle(pos.x,pos.y,xvel,yvel,colour);
		}
	}
}

SysPlayer = function()
{
	function CallectPowerUps(component)
	{
		if ( component && component.Collided)
		{
//				console.log("powerup");
			component.Collided = false;
		}
	}

	ProcessPlayers();
	ProcessShots();
	
	function ProcessPlayers()
	{
		for ( var eIdx=0; eIdx < entities[LAYER_PLAYER].length; eIdx++)
		{
			var e = entities[LAYER_PLAYER].data[eIdx];
			if (e && e.components.Player && e.components.Position && e.components.Physics && e.components.Rotation)
			{
				var pos = e.components.Position.Position;
				var rotation = e.components.Rotation.Rotation;
				var physics = e.components.Physics;
				var player = e.components.Player;

				CallectPowerUps(e.components.Collide);
				
				if (keystate[player.KeyRight])
				{
					rotation += player.Rotaterate; //physics.Rotatespeed;
				}
				if (keystate[player.KeyLeft])
				{
					rotation -= player.Rotaterate; //physics.Rotatespeed;
				}

				if (keystate[player.KeyAccelerate])
				{
					// covert the rotation angle to a vector
					var accel = Vector ( Math.cos(rotation), Math.sin(rotation));
					var xp = accel.x;
					var yp = accel.y;
					accel.SetMagnitude(physics.Acceleration);
					// Add the vector to the current acceleration vector
					physics.Velocity = physics.Velocity.Add(accel);

					prefabs.CreateParticle(pos.x - xp*20,pos.y - yp*20,-Math.random()*xp*4,-Math.random()*yp*4,"White");
				}

				player.ShotElapsedTime++;
				if ( keystate[player.KeyShoot] && player.ShotElapsedTime >= player.ShotRate)
				{
					var direction = Vector ( Math.cos(rotation), Math.sin(rotation));
					var shotpos = Vector(pos.x + direction.x * 10, pos.y + direction.y * 10);
					direction.SetMagnitude(12);
					CreateShot(shotpos, direction, rotation);
					player.ShotElapsedTime = 0;
					PlaySound(0);
				}
				
				e.components.Rotation.Rotation = rotation;
			}
		}
	}
	
	function ProcessShots()
	{
		for ( var eIdx=entities[LAYER_PLAYER_SHOT].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[LAYER_PLAYER_SHOT].data[eIdx];
			if (e && e.components.PlayerShot && e.components.Collide ) 
			{
				if ( e.components.Collide.Collided)
				{
					e.components.Collide.Destroy = true;
				}
			}		
		}
	}
	
	function CreateShot(pos,velocity, rotate)
	{
		prefabs.CreatePlayerShot(pos.x,pos.y,velocity.x,velocity.y, rotate)
	}
}

SysDestroyer = function()
{
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Lifespan )
			{
				e.components.Lifespan.Age+= 1;
				if ( e.components.Lifespan.Age >= e.components.Lifespan.MaxAge)
				{
					if ( e.components.Prefab )
					{
						prefabs.Delete(e.components.Prefab.Type, e.components.Prefab.Position)
					}
					entities[layer].Delete(eIdx);
				}
			}
			if (e && e.components.Collide)
			{
				if ( e.components.Collide.Destroy)
				{
					if ( e.components.Prefab )
					{
						prefabs.Delete(e.components.Prefab.Type, e.components.Prefab.Position);
					}
					entities[layer].Delete(eIdx);
				}
			}
		}
	}
}

Vector = function(x,y)
{
	var obj = {};
	
	obj.x = x;
	obj.y = y;

	obj.Add = function(v1)
	{
		return Vector(obj.x+v1.x, obj.y+v1.y);
	}

	obj.Subtract = function(v1)
	{
		return Vector(obj.x-v1.x, obj.y-v1.y);
	}

	obj.Multiply = function(v1)
	{
		return Vector(obj.x*v1.x, obj.y*v1.y);
	}

	obj.Magnitude = function()
	{
		return Math.sqrt(obj.x*obj.x + obj.y*obj.y);
	}

	obj.Normalise = function()
	{
		var mag = obj.Magnitude();
		obj.x /= mag;
		obj.y /= mag;
	}

	obj.SetMagnitude = function(newMagnitude)
	{
		obj.Normalise();
		obj.x *= newMagnitude;
		obj.y *= newMagnitude;
	}

	obj.DotProduct = function(v)
	{
		return obj.x * v.x + obj.y * v.y;
	}

	obj.ScalarMultiply = function(scalar)
	{
		obj.x *= scalar;
		obj.y *= scalar;
	}

	return obj;
}

BuildSounds = function ()
{
	// player shot
	audio[0] = CreateSound(2000,200,0,500,.5,0,.5,.15);
	// player explode
	audio[1] = CreateSound(7000,4000,0,0,1,0,0.25,.125);
	// invader move
//	audio[2] = CreateSound(300,300,2000,150,.5,0.0,.2,.2);
//	audio[3] = CreateSound(200,200,2000,150,.5,0.0,.2,.2);
//	audio[4] = CreateSound(250,250,2000,150,.5,0.0,.2,.2);
//	audio[5] = CreateSound(200,200,2000,150,.5,0.0,.2,.2);
	// invader explode
	audio[2] = CreateSound(100,0,4000,100,1,0.0,.75,.75);
}

CreateSound = function ( startFreq, endFreq, noiseFreq, noiseFreqAdj, startVol, endVol, duration, freqDuration)
{
	var noiseFreq = QBSynthJS.InputMultiplier(
		QBSynthJS.InputOscilatorRandom(QBSynthJS.InputBasic(noiseFreq),0), 
		QBSynthJS.InputBasic(noiseFreqAdj));

	var freqShiftAndNoise = QBSynthJS.InputAdd(
		QBSynthJS.InputLinearRepeat(startFreq,endFreq,QBSynthJS.InputBasic(1/freqDuration)), 
		noiseFreq);
	
	var volume = QBSynthJS.InputLinearRepeat(startVol,endVol,QBSynthJS.InputBasic(1/duration));

	var osc = QBSynthJS.InputMultiplier(
		QBSynthJS.InputOscilatorSquare(freqShiftAndNoise,0), 
		volume)
	
	output = QBSynthJS.GenerateData(8000, duration, osc);
	var wav = QBSound.BuildWavData(output,8000,0);
	return QBSound.CreateAudioObject(wav);
}

PlaySound = function(i)
{
	var a=audio[i];
	a.pause();
	a.currentTime=0;
	a.play();
}

var QBSynthJS = new function()
{
	var _this = this;

	this.InputBasic = function (value)
	{
	  var obj = {};
	  obj.GetValue = function(timeSpan)
	  {
	    return value;
	  }
	  return obj;
	}

	this.InputLinearRepeat = function(startValue, endValue,frequency)
	{
	  var obj = {};
	  var totalTime = 0;
	  var duration = 1/frequency.GetValue(0);
	  obj.GetValue = function(timeSpan)
	  {
	  	var newDuration = 1/frequency.GetValue(timeSpan); 
	  	totalTime += timeSpan;
	  	while ( totalTime >= duration)
	  	{
			totalTime -= duration;
			duration = newDuration;
	  	}
	    return startValue + (endValue - startValue) / duration * totalTime;
	  }
	  return obj;
	}

	this.InputMultiplier = function(input1, input2)
	{
	  var obj = {};
	  obj.GetValue = function(timeSpan)
	  {
	    return input1.GetValue(timeSpan) * input2.GetValue(timeSpan);
	  }
	  return obj;
	}

	this.InputAdd = function(input1, input2)
	{
	  var obj = {};
	  obj.GetValue = function(timeSpan)
	  {
	    return input1.GetValue(timeSpan) + input2.GetValue(timeSpan);
	  }
	  return obj;
	}

	this.InputOscilatorSquare = function(frequency, startAngle)
	{
		var obj = {};
		var angle = 0;

		if ( startAngle !== undefined)
			angle = startAngle;

		obj.GetValue = function(timeSpan)
		{
			var angleInc = timeSpan * frequency.GetValue(timeSpan) * (Math.PI * 2);

			angle += angleInc;
			if ( angle >= Math.PI * 2)
			  angle -= Math.PI * 2;

		    var value = Math.sin(angle);
		    if ( value >= 0)
		     	return 1
		    else
		     	return -1;
		};
		return obj;
	}

	this.InputOscilatorRandom = function(frequency, startAngle)
	{
	 	var obj = {};
	  	var angle = 0;
		var value = (Math.random()*2) - 1;

		if ( startAngle !== undefined)
	   		angle = startAngle;

		obj.GetValue = function(timeSpan)
		{
			var angleInc = timeSpan * frequency.GetValue(timeSpan) * (Math.PI * 2);

			angle += angleInc;
			if ( angle > Math.PI * 2)
			{
			  angle -= Math.PI * 2;
			  value = (Math.random()*2) - 1;
			}
	    	return value;
	  	};
		return obj;
	}

	this.GenerateData = function(bitrate, duration, osc)
	{
	  var values = [];
	  var valueSize = 1;
	  var inc = 1/bitrate;

	  values[0] = osc.GetValue(0);
	  for ( var x = inc; x <= duration;x = x + inc)
	  {
	    var value = osc.GetValue(inc);

	    values[valueSize++] = value;
	  }

	  return values;
	}
}

var QBSound = new function()
{
	function insertLong(inString, index, inValue)
	{
		var retString = inString.substr(0,index);
		for (i = 0; i < 4; ++i) {
		  retString += String.fromCharCode(inValue & 255);
		  inValue = inValue >> 8;
		}
		retString += inString.substr(index+4);
		return retString;
	}

	this.BuildWavData = function (values,bitrate,channel)
	{
		var n = values.length;
		var wavData = "RIFF****WAVEfmt \x10\x00\x00\x00\x01\x00\x01\x00********\x01\x00\x08\x00data****";

		// ChunkSize
		var numval = n + 36;
		wavData=insertLong(wavData,4,numval);

		numval = bitrate; // byterate
		wavData = insertLong(wavData,24,numval);
	 
		  // BitRate
		numval = bitrate * 8; //44100;
		wavData = insertLong(wavData,28,numval);
	 
		  // Subchunk2Size
	//      insertLong(n);
		numval = n;
		wavData = insertLong(wavData,40,numval);
		  
		// Output sound data
		for (var i = 0; i < n; ++i)
		{
			var charCode = Math.round(Math.min(127, Math.max(-127, values[i]*127))+127);
			wavData += String.fromCharCode(charCode);
		}
		
		return wavData		
	}

	this.CreateAudioObject = function (wavData)
	{
		var encoded = btoa(wavData);
		src = 'data:audio/wav;base64,' + encoded;
		var a = new Audio();
		a.src = src;
		return a;
	}
}

function PrefabManager()
{
	var obj = {};
	
	var collections = new Array();
	for ( var c = 0; c <= PREFAB_LAST; c++ )
	{
		collections[c] = QuickCollection();
	}
	
	var players = collections[PREFAB_PLAYERS];
	var particles = collections[PREFAB_PARTICLES];
	var playerShots = collections[PREFAB_PLAYERSHOTS];
	var EnemyA = collections[PREFAB_ENEMYA];
	var EnemyB = collections[PREFAB_ENEMYB];
	var PowerUps = collections[PREFAB_POWERUPS];
	var RadarHud = collections[PREFAB_RADARHUD];
	var Spawner = collections[PREFAB_SPAWNER];

	obj.Count = function(type)
	{
		if ( type == "EnemyA")
			return EnemyA.length;
		if ( type == "EnemyB")
			return EnemyB.length;
	}
	
	obj.CreatePlayer = function (keyleft, keyright, keyaccelerate, keyshoot)
	{
		var entity = players.Reclaim();
		if ( entity == null )
		{
			entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics()); 
			entity.AddComponent(CompVisible());
			entity.AddComponent(CompPlayer());
			
			entity.AddComponent(CompScreenBounce());
			entity.AddComponent(CompCollide(LAYER_POWER_UP));
			entity.AddComponent(CompPrefab(PREFAB_PLAYERS));
			entity.AddComponent(CompCamera());
			entity.AddComponent(CompGamePos());
			entity.AddComponent(CompRadar());
			entity.AddComponent(CompRotation());
		}
		
		ec = entity.components.Prefab;
//		ec.Type = "Player";
		ec.Position = players.length;
		

		var ec = entity.components.Position;
		ec.Position.x = 0;
		ec.Position.y = 0;

		var ec = entity.components.Rotation;
		ec.Rotation = 0;

		ec = entity.components.Physics
		ec.Velocity.x = 0;
		ec.Velocity.y = 0;
		ec.Acceleration = .1;
		ec.Drag = .99;
//		ec.Rotatespeed = Math.PI/50;
		ec.Maxvelocity = 8;

		ec = entity.components.Visible;
		ec.Drawdata = shipData;
		ec.Colour = "White";
		ec.Layer = LAYER_PLAYER;

		ec = entity.components.Player;
		ec.KeyLeft = keyleft;
		ec.KeyRight = keyright;
		ec.KeyAccelerate = keyaccelerate;
		ec.KeyShoot = keyshoot;
		
		entities[LAYER_PLAYER].Insert(entity);
		
		return entity;	
	}
	
	obj.CreateParticle = function (xpos, ypos, xvel, yvel, colour)
	{
		var entity = particles.Reclaim();
		if ( entity == null )
		{
			entity = Entity();
			var colour = colour;
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompLifeSpan());
			entity.AddComponent(CompVisible());
			entity.AddComponent(CompVisible(explosionData,colour,0));
			entity.AddComponent(CompPrefab(PREFAB_PARTICLES));
			entity.AddComponent(CompGamePos());
			
			console.log("Creating particle");
		}

		ec = entity.components.Prefab;
//		ec.Type = "Particle";
		ec.Position = particles.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;
		ec.Rotation = 0;

		ec = entity.components.Physics
		ec.Velocity.x = xvel;
		ec.Velocity.y = yvel;
		ec.Acceleration = 1;
		ec.Drag = 1;

		ec = entity.components.Visible;
//		ec.Drawdata = explosionData;
		ec.Colour = colour;
//		ec.Layer = 0;

		ec = entity.components.Lifespan;
		ec.MaxAge = 50 + Math.floor(Math.random() * 20);
		ec.Age = 0;

		particles.Insert(entity);
		entities[0].Insert(entity);
		
		return entity;
	}
	
	obj.CreateEnemyA = function ( xpos, ypos)
	{
		var entity = EnemyA.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			var colour = "Yellow";

			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompScreenWrap());
			entity.AddComponent(CompEnemyA());

			entity.AddComponent(CompCollide(LAYER_PLAYER | LAYER_PLAYER_SHOT));
			entity.AddComponent(CompVisible(enemyData,colour,LAYER_ENEMY));
			entity.AddComponent(CompPrefab(PREFAB_ENEMYA));
			entity.AddComponent(CompGamePos());
			entity.AddComponent(CompRadar());
			entity.AddComponent(CompRotation());
		}

		ec = entity.components.Prefab;
		ec.Position = EnemyA.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

		var ec = entity.components.Rotation;
		ec.Rotation = 0;
		ec.Rotatespeed = Math.PI/25;
		
		ec = entity.components.Collide
		ec.Collided = false;
		ec.Destroy = false;

		ec = entity.components.Physics
		ec.Velocity.x = (Math.random()-.5)*4;
		ec.Velocity.y = (Math.random()-.5)*4;
		ec.Acceleration = 1;
		ec.Drag = 1;

//		ec = entity.components.Visible;
//		ec.Drawdata = enemyData;
//		ec.Colour = "Yellow";
//		ec.Layer = LAYER_ENEMY;

		EnemyA.Insert(entity);
		entities[LAYER_ENEMY].Insert(entity);

		return entity;
	}

	obj.CreateEnemyB = function ( xpos, ypos)
	{
		var entity = EnemyB.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			var colour = "Green";

			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompScreenBounce());
			entity.AddComponent(CompEnemyB());
			
			entity.AddComponent(CompCollide(LAYER_PLAYER | LAYER_PLAYER_SHOT));
			entity.AddComponent(CompVisible(enemyData,colour,LAYER_ENEMY));
			entity.AddComponent(CompPrefab(PREFAB_ENEMYB));
			entity.AddComponent(CompRadar());
		}

		ec = entity.components.Prefab;
		ec.Position = EnemyB.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

//		var ec = entity.components.Rotation;
//		ec.Rotation = 0;
		
		ec = entity.components.Collide
		ec.Collided = false;
		ec.Destroy = false;

		ec = entity.components.Physics
		ec.Velocity.x = (Math.random()-.5)*4;
		ec.Velocity.y = (Math.random()-.5)*4;
		ec.Acceleration = 1;
		ec.Drag = 1;

//		ec = entity.components.Visible;
//		ec.Drawdata = enemyData;
//		ec.Colour = "Green";
//		ec.Layer = LAYER_ENEMY;

		EnemyB.Insert(entity);
		entities[LAYER_ENEMY].Insert(entity);

		return entity;
	}
	
	obj.CreatePlayerShot = function (xpos,ypos,xvel,yvel, rotation)
	{
		var entity = playerShots.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompLifeSpan());
			entity.AddComponent(CompVisible(playerShotData,"White",LAYER_PLAYER_SHOT));
			entity.AddComponent(CompCollide(LAYER_ENEMY));
			entity.AddComponent(CompPlayerShot());
			entity.AddComponent(CompPrefab(PREFAB_PLAYERSHOTS));
//			entity.AddComponent(CompGamePos());
			entity.AddComponent(CompRotation());

			console.log("Creating playershot");
		}

		ec = entity.components.Prefab;
		ec.Position = playerShots.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

		var ec = entity.components.Rotation;
		ec.Rotation = rotation;

		ec = entity.components.Physics
		ec.Velocity.x = xvel;
		ec.Velocity.y = yvel;
		ec.Acceleration = 0;
		ec.Drag = 1;

		var ec = entity.components.Lifespan;
		ec.MaxAge = 50;
		ec.Age = 0;

//		ec = entity.components.Visible;
//		ec.Drawdata = playerShotData;
//		ec.Colour = "White";
//		ec.Layer = LAYER_PLAYER_SHOT;

		ec = entity.components.Collide
		ec.Collided = false;
		ec.Destroy = false;
		
		playerShots.Insert(entity);
		entities[LAYER_PLAYER_SHOT].Insert(entity);
		
		return entity;
	}
	
	obj.CreatePowerUp = function (xpos,ypos,xvel,yvel)
	{
		var entity = PowerUps.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompLifeSpan());
			entity.AddComponent(CompVisible(powerUpData,"Cyan",LAYER_POWER_UP));
			entity.AddComponent(CompCollide(LAYER_PLAYER));
			entity.AddComponent(CompPowerUp());
			entity.AddComponent(CompPrefab(PREFAB_POWERUPS));
			entity.AddComponent(CompGamePos());
			entity.AddComponent(CompRotation());
		}

		ec = entity.components.Prefab;
		ec.Position = PowerUps.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

		var ec = entity.components.Rotation;
		ec.Rotation = 0;
		ec.Rotatespeed = -Math.PI / 50;

		ec = entity.components.Physics
		ec.Velocity.x = xvel;
		ec.Velocity.y = yvel;
		ec.Acceleration = 0;
		ec.Drag = .7;


		var ec = entity.components.Lifespan;
		ec.MaxAge = 600;
		ec.Age = 0;

		ec = entity.components.Collide
		ec.Collided = false;
		ec.Destroy = false;
		
		PowerUps.Insert(entity);
		entities[LAYER_POWER_UP].Insert(entity);
		
		return entity;
	}
	
	obj.CreateRadarHud = function()
	{
		var entity = playerShots.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompVisible());
			entity.AddComponent(CompPrefab(PREFAB_RADARHUD));
		}

		var ec = entity.components.Position;
		ec.Position.x = 0;
		ec.Position.y = -screenHeight/2 + gameHeight/10/2 + 2;

		ec = entity.components.Visible;
		ec.Drawdata = radarBorderData;
		ec.Colour = "White";
		ec.Layer = LAYER_HUD;

		RadarHud.Insert(entity);
		entities[LAYER_HUD].Insert(entity);

		return entity;
	}

	obj.CreateSpawner = function( xpos, ypos, spawnRate, prefabType)
	{
		var entity = Spawner.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompSpawner());
			entity.AddComponent(CompPrefab(PREFAB_SPAWNER));
		}

		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

		var ec = entity.components.Spawner;
		ec.SpawnRate = spawnRate;
		ec.ElapsedTime = 0;
		ec.SpawnPrefabType = prefabType;

		Spawner.Insert(entity);
		entities[LAYER_ENEMY].Insert(entity);

		return entity;
	}
	
	obj.Delete = function(type, position)
	{
		var collection = collections[type];
		if ( collection.length > 1)
		{
//			// Bit of a Hack
//			// we need to repoint the last entity prefab entry to contain the position
//			// of the one we are deleting ( as that is where it will end up after the delete )
			collection.data[collection.length-1].components.Prefab.Position = position;
		}
		collection.Delete(position);
	}
	
	return obj;
}

function QuickCollection()
{
	var obj = {};
	obj.length = 0;
	obj.data = new Array();
	
	obj.Insert = function(item)
	{
		obj.data[obj.length] = item;
		obj.length++;
	}
	
	// This function will return the first object in the list
	// that is now "deleted".
	obj.Reclaim = function()
	{
		if ( obj.length <= obj.data.length)
		{
			return obj.data[obj.length]
		}
		return null;
	}
	
	obj.Delete = function(pos)
	{
		if ( pos > obj.length - 1)
			return;
			
		if ( pos == obj.length - 1)
		{
			obj.length--;
		}
		else
		{
			// swap with the last item in the collection
			var temp = obj.data[pos];
			obj.data[pos] = obj.data[obj.length-1];
			obj.data[obj.length-1] = temp;
			obj.length--;
		}
	}
	
	return obj;
}

// last piece of code is to start the game
init();
</script>
</body>
</html>
