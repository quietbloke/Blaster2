<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Micro Invasion</title>
<style>
Body{background-color:#282828;color:#ffffff;margin:0px;}
Canvas{position:fixed;background-color:black;}
#counter{position:absolute; bottom:0;right:0;color:#ffffff;display:hidden;}
#debug{position:absolute; bottom:0;left:0;color:#ffffff;display:hidden;}
</style>
</head>
<body>
	<canvas id="myCanvas">Sorry... your browser does not support the canvas element.</canvas>
	<p id="counter">counter</p>
	<p id="debug">debug</p>
</body>
<script>
// Global variables
// used for calculating and showing the frames per second
var dwFrames=0;
var dwCurrentTime=0;
var dwLastUpdateTime=0;
var dwElapsedTime=0;
var fpsText;

var keystate = new Array();

var canvas;
var ctx;

var audio = new Array();

// browser stuff
function doResize()
{
	var canvas = document.getElementById('myCanvas');
	var scrH = window.innerHeight;
	var scrW = window.innerWidth;

	var ratioX = 256 / scrW;
	var ratioY = 144 / scrH;

	var ratio = Math.max(ratioX,ratioY);
		
	var width = 256 / ratio;
	var height = 144 / ratio;

	canvas.style.height = height+"px";
	canvas.style.width = width+"px";
	canvas.style.marginLeft = (scrW-width)/2;
	canvas.style.marginTop = (scrH-height)/2;
}

// lots of constants
const SCREEN_WIDTH = 1280;
const SCREEN_HEIGHT = 768;
const GAME_WIDTH = SCREEN_WIDTH * 4;
const GAME_HEIGHT = SCREEN_HEIGHT;
const GAME_X_MAX  =  GAME_WIDTH/2;
const GAME_X_MIN  =  -GAME_X_MAX;
const GAME_Y_MAX  =  GAME_HEIGHT/2;
const GAME_Y_MIN  =  -GAME_Y_MAX;

const LAYER_PLAYER = 1;
const LAYER_ENEMY = 2;
const LAYER_POWER_UP = 4;
const LAYER_PLAYER_SHOT = 8;
const LAYER_ENEMY_SHOT = 16;
const LAYER_HUD = 32;
const LAYER_LAST_LAYER = 32;

const PREFAB_PLAYERS = 0;
const PREFAB_PARTICLES = 1;
const PREFAB_PLAYERSHOTS = 2;
const PREFAB_ENEMYA = 3;
const PREFAB_ENEMYB = 4;
const PREFAB_POWERUPS = 5;
const PREFAB_RADARHUD = 6;
const PREFAB_SPAWNER = 7;
const PREFAB_SWARMLEADER = 8;
const PREFAB_SWARMMEMBER = 9;
const PREFAB_LAST = 9;

const COMP_POSITION = 0;
const COMP_ROTATION = 1;
const COMP_VISIBLE = 2;
const COMP_PHYSICS = 3;
const COMP_PLAYER = 4;
const COMP_LIFESPAN = 5;
const COMP_SCREENWRAP = 6;
const COMP_SCREENBOUNCE = 7;
const COMP_ENEMYA = 8;
const COMP_ENEMYB = 9;
const COMP_POWERUP = 10;
const COMP_PREFAB = 11;
const COMP_CAMERA = 12;
const COMP_GAMEPOS = 13;
const COMP_RADAR = 14;
const COMP_COLLIDE = 15;
const COMP_SPAWNER = 16;
const COMP_ENEMY_TEAM_LEADER = 17;
const COMP_ENEMY_TEAM_MEMBER = 18;

const SOUND_SHOT = 0
const SOUND_POWERUP = 1
const SOUND_ENEMY_EXPLODE = 2

const FPS = 50;

var entities = {};	// Entities exists in layers
var systems = {};

const DRAW_DATA_MOVE = 0;
const DRAW_DATA_LINE = 1;

var shipData = [[DRAW_DATA_MOVE,-20,-10],[DRAW_DATA_LINE,20,0],[DRAW_DATA_LINE,-20,10],[DRAW_DATA_LINE,-20,-10] ];
var enemyData = [[DRAW_DATA_MOVE,-10,-10],[DRAW_DATA_LINE,10,-10],[DRAW_DATA_LINE,10,10],[DRAW_DATA_LINE,-10,10],[DRAW_DATA_LINE,-10,-10] ];
var powerUpData = [[DRAW_DATA_MOVE,-5,-5],[DRAW_DATA_LINE,5,5],[DRAW_DATA_MOVE,5,-5],[DRAW_DATA_LINE,-5,5]];
var explosionData = [[DRAW_DATA_MOVE,-1,-1],[DRAW_DATA_LINE,1,-1],[DRAW_DATA_LINE,1,1],[DRAW_DATA_LINE,-1,1],[DRAW_DATA_LINE,-1,-1] ];
var playerShotData = [[DRAW_DATA_MOVE,-6,-1],[DRAW_DATA_LINE,6,-1],[DRAW_DATA_LINE,6,1],[DRAW_DATA_LINE,-6,1],[DRAW_DATA_LINE,-6,-1] ];
var radarBorderData = [[DRAW_DATA_MOVE, GAME_X_MIN / 10-1, GAME_Y_MIN / 10 - 1], 	
	[DRAW_DATA_LINE, GAME_X_MIN / 10 - 1, GAME_Y_MAX/10 + 1],
	[DRAW_DATA_LINE, GAME_X_MAX / 10 + 1, GAME_Y_MAX/10 + 1],
	[DRAW_DATA_LINE, GAME_X_MAX / 10 + 1, GAME_Y_MIN/10 - 1],
	[DRAW_DATA_LINE, GAME_X_MIN / 10 - 1, GAME_Y_MIN/10 - 1]];

var prefabs = PrefabManager();

var previousTime = (new Date).getTime();
var timerElasped = 0;
var timerOverflow = 0;
var expectedTimeSpan = Math.floor(1000/FPS);

var dwTimeCarriedOver = 0;
var updateRate = Math.floor(1000/FPS);
var dwDrawSkipFrames = 0;

init = function()
{
	if ( typeof(localStorage != "undefined"))
		hiscore = localStorage.getItem("highscore");

	canvas = document.getElementById('myCanvas');
	if (canvas.getContext)
	{
		canvas.width = SCREEN_WIDTH;
		canvas.height = SCREEN_HEIGHT;

		// when the window resizes we want to resize the canvas
		window.onresize = function() { doResize(); };
		doResize();

		BuildSounds();

		document.addEventListener("keydown", function (e) { keystate[e.keyCode] = 1;} );
		document.addEventListener("keyup", function (e) { keystate[e.keyCode] = 0; });	

		// set timer to game main function
		ctx = canvas.getContext('2d');

		ctx.translate(SCREEN_WIDTH/2, SCREEN_HEIGHT/2);
		
		entities = QuickCollection();
		for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
		{
			entities[layer] = QuickCollection();
		}
		
		prefabs.CreatePlayer(37,39,38,90);

		prefabs.CreateSpawner(-GAME_WIDTH/2,0,200,"SwarmA", 80);
		prefabs.CreateSpawner(GAME_WIDTH/2,0,40,"EnemyB", 50);
		prefabs.CreateSpawner(-GAME_WIDTH/2,0,40, "EnemyA", 50);
		
		prefabs.CreateRadarHud();
		
//		prefabs.CreateSwarmA ( 0,0);
		
		timerId = setInterval ( main, Math.floor(1000/FPS));
	}
}

main = function ()
{
	// fps code .... this can go when we are done
	dwFrames++;
	dwCurrentTime = (new Date).getTime();
	dwElapsedTime = dwCurrentTime - dwLastUpdateTime;
	if(dwElapsedTime >= 1000)
	{        
		fpsText = "FPS " + dwFrames;
		dwLastUpdateTime = dwCurrentTime;
		dwFrames = 0;
	}
	var l = document.getElementById('counter');
	l.textContent = fpsText;
	// end of fps code
	
	dwElapsedTime += dwTimeCarriedOver;
	
//		this.dwCurrentTime = (new Date).getTime();	
//		this.dwElapsedTime = this.dwCurrentTime - this.dwLastUpdateTime + this.dwTimeCarriedOver;
	if(this.dwElapsedTime >= updateRate)
	{
		if ( this.dwDrawSkipFrames > 0)
		{
			this.dwDrawSkipFrames--;
		}
		else
		{
			ctx.globalAlpha = 0.4;
			ctx.fillRect(-SCREEN_WIDTH/2, -SCREEN_HEIGHT/2, SCREEN_WIDTH, SCREEN_HEIGHT);
			ctx.globalAlpha = 1;

			SysRender();
		}

		// If drawing the screen takes longer than a frame then
		// find out how many times drawing must be skipped
		dwDrawElapsedTime = (new Date).getTime() - dwLastUpdateTime + dwTimeCarriedOver - dwElapsedTime;
		if ( this.dwDrawElapsedTime > this.updateRate)
		{
			dwDrawSkipFrames = Math.floor(dwDrawElapsedTime / updateRate);
			console.log("skipping " + dwDrawSkipFrames);
		}

		var frames = Math.floor(dwElapsedTime / updateRate );
		if (frames > 4 )
			frames = 4;
		dwTimeCarriedOver = dwElapsedTime % updateRate;
		dwLastUpdateTime = dwCurrentTime;

		for ( var f = 0; f < frames; f++)
		{
			SysCollisions();
			SysPlayer();
			SysEnemies();
			SysPhysics();
			SysCamera();
			SysDestroyer();
		}
	}
}

GameState = function()
{
	obj = {};
	
	obj.Init = function()
	{
	}

	obj.Update = function()
	{
	}
}

var nextId = 0;
// An entity is just a unique id and contains a collection of components
Entity = function()
{
	var obj = {};
	obj.components = new Array();
	obj.ID = nextId;
	nextId++;
	
	obj.AddComponent= function ( component )
	{
		obj.components[component.Name] = component;
	}
	
	obj.DeleteComponent= function ( componentName )
	{
		delete obj.components[componentName];
	}
	
	return obj;
}

// components have a name and can contain a block of data
// For the moment all components are prefixed with Comp

CompPosition = function (xpos, ypos)
{
	return {"Name" : "Position", 
		"Position" : new Vector(xpos,ypos)};
}

CompRotation = function (rotation)
{
	return {"Name" : "Rotation", 
		"Rotation" : rotation,
		"Rotatespeed" : 0};
}

CompVisible = function (drawData,colour,layer)
{
	// given the data calculate the bounding box
	var topleft = Vector(0,0);
	var bottomright = Vector(0,0);

	var drawDataTransformed = [];
	// copy drawdata for transformed data
	for ( var pIdx = 0; pIdx < drawData.length; pIdx++)
	{
		var p = drawData[pIdx];
		drawDataTransformed[pIdx] = [p[0],p[1], p[2]];
	}
	
	return {"Name" : "Visible", 
		"Drawdata" : drawData,
		"DrawdataTransformed" : drawDataTransformed,
		"Colour" : colour,
		"Layer" : layer,
		"Topleft" : topleft,
		"Bottomright" : bottomright};
}

CompPhysics = function (xvel, yvel, acceleration, drag, maxvelocity)
{
	return {"Name" : "Physics", 
		"Velocity" : new Vector(xvel,yvel), 
		"Acceleration" : acceleration, 
		"Drag" : drag,
		"Maxvelocity" : maxvelocity};
}

CompPlayer = function ( leftkey, rightkey, acceleratekey, shootkey)
{
	return {"Name" : "Player", 
		"KeyLeft" : leftkey, 
		"KeyRight" : rightkey, 
		"KeyAccelerate" : acceleratekey,
		"KeyShoot" : shootkey,
		"ShotRate" : 10,
		"ShotElapsedTime" : 0,
		"Rotaterate" : Math.PI/40 };
}

CompLifeSpan = function ( maxAge )
{
	return {"Name" : "Lifespan", 
		"MaxAge" : maxAge, 
		"Age" : 0 };
}

CompScreenWrap = function ()
{
	return {"Name" : "Screenwrap" };
}

CompScreenBounce = function ()
{
	return {"Name" : "Screenbounce" };
}

CompEnemyA = function ()
{
	return {"Name" : "EnemyA" };
}

CompEnemyB = function ()
{
	return {"Name" : "EnemyB" };
}

CompPowerUp = function ()
{
	return {"Name" : "PowerUp" };
}

CompPrefab = function (type, pos)
{
	return {"Name" : "Prefab", "Type" : type, "Position" : pos };
}

CompPlayerShot = function ()
{
	return {"Name" : "PlayerShot"};
}

CompCamera = function ()
{
	return {"Name" : "Camera"};
}

CompGamePos = function ()
{
	return {"Name" : "Gamepos"};
}

CompRadar = function ()
{
	return {"Name" : "Radar"};
}

CompCollide = function (collisionLayers)
{
	return {"Name" : "Collide",
		"Collisionlayers" : collisionLayers, 
		"Collided" : false,
		"Destroy" : false};
}

CompSpawner = function(xpos,ypos,spawnRate, prefabType, spawnMax)
{
	return {"Name" : "Spawner",
		"SpawnRate" : spawnRate, 
		"SpawnPrefab" : prefabType,
		"SpawnMax" : spawnMax,
		"ElapsedTime" : 0};
}

CompEnemyTeamLeader = function(xpos,ypos)
{	
	return {"Name" : "EnemyTeamLeader",
		"TeamMembers" : QuickCollection(),
		"YPosAngleOffset" : 0
		};
}

CompEnemyTeamMember = function(xOff,yOff)
{	
	return {"Name" : "EnemyTeamMember",
			"Position" : new Vector(xOff,yOff),
			"DesiredPosition" : new Vector(xOff,yOff),
			"TeamLeader" : Entity() };
}

// Systems will perform actions on any entities that contains all the 
// components they require.
// For the moment all Systems are prefixed with Sys
SysRender = function()
{
	// Find the radar hud entity if there is one
	// Any entity in the HUD layer is considered a HUD
	var radarEntity = null;
	var hud_x_divider = 1;
	var hud_y_divider = 1;
	for ( var eIdx=entities[LAYER_HUD].length-1; eIdx >= 0; eIdx--)
	{
		var e = entities[LAYER_HUD].data[eIdx];
		if ( e.components.Position && e.components.Visible )
		{
			radarEntity = e;
			hud_x_divider = Math.floor(GAME_WIDTH / ( radarEntity.components.Visible.Bottomright.x - radarEntity.components.Visible.Topleft.x - 4));
			hud_y_divider = Math.floor(GAME_HEIGHT / ( radarEntity.components.Visible.Bottomright.y - radarEntity.components.Visible.Topleft.y - 4));
		}
	}

	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Position && e.components.Visible)
			{
				var pos = e.components.Position.Position;
				var data = e.components.Visible.Drawdata;
				var transformedData = e.components.Visible.DrawdataTransformed;
				if ( e.components.Rotation)
				{
					var rotate = e.components.Rotation.Rotation;
//					rotated = [];
					for ( var pIdx = 0; pIdx < data.length; pIdx++)
					{
						var p = data[pIdx];
						newX = p[1] * Math.cos(rotate) - p[2] * Math.sin(rotate);
						newY = p[1] * Math.sin(rotate) + p[2] * Math.cos(rotate);

						transformedData[pIdx] = [p[0],newX, newY];
					}
				}
				// Don't know if this is the place to do this but
				// as we have now rotated and are about to draw
				// we can recalculate the bounding box
				var topleft = e.components.Visible.Topleft;
				var bottomright = e.components.Visible.Bottomright;
				topleft.x = 0;
				topleft.y = 0;
				bottomright.x = 0;
				bottomright.y = 0;

				for ( var pIdx = 0; pIdx < transformedData.length; pIdx++)
				{
					var p = transformedData[pIdx];
					if ( p[1] < topleft.x)
						topleft.x = p[1];
					if ( p[1] > bottomright.x)
						bottomright.x = p[1];
					if ( p[2] < topleft.y)
						topleft.y = p[2];
					if ( p[2] > bottomright.y)
						bottomright.y = p[2];
				}
				topleft.x += 2;
				topleft.y += 2;
				bottomright.x -= 2;
				bottomright.y -= 2;

				// now draw the shape
				if ( pos.x + bottomright.x > -SCREEN_WIDTH/2 || pos.x + topleft.x < SCREEN_WIDTH/2)
				{
					ctx.beginPath();
					
					var scrX = pos.x;
					var scrY = pos.y;
				
					for ( var pIdx = 0; pIdx < transformedData.length; pIdx++)
					{
						var p = transformedData[pIdx];
						scrX = pos.x + p[1];
						scrY = pos.y + p[2];
						if ( p[0] == DRAW_DATA_MOVE)
						{
							ctx.moveTo(scrX,scrY);
						}
						else
						{
							ctx.lineTo(scrX,scrY);
						}
					}
					ctx.strokeStyle=e.components.Visible.Colour;
					ctx.stroke();
				}
				// and draw the radar version
				if ( e.components.Radar )
				{
					// convert the game position into a position 
					// that fits within the HUD
					var hud_x_divider = (GAME_WIDTH / ( radarEntity.components.Visible.Bottomright.x - radarEntity.components.Visible.Topleft.x - 3));
					var hud_y_divider = (GAME_HEIGHT / ( radarEntity.components.Visible.Bottomright.y - radarEntity.components.Visible.Topleft.y - 3));
					
					ctx.beginPath();
					scrX = pos.x / hud_x_divider + radarEntity.components.Position.Position.x;
					scrY = pos.y / hud_y_divider + radarEntity.components.Position.Position.y;
					ctx.moveTo(scrX-2,scrY-2);
					ctx.lineTo(scrX+2,scrY-2);
					ctx.lineTo(scrX+2,scrY+2);
					ctx.lineTo(scrX-2,scrY+2);
					ctx.lineTo(scrX-2,scrY-2);
					ctx.strokeStyle=e.components.Visible.Colour;
					ctx.stroke();
				}
				
				// For debug puposes we will draw the bounding box
	//			var topleft = e.components.Visible.Topleft;
	//			var bottomright = e.components.Visible.Bottomright;
	//			ctx.beginPath();
	//			ctx.moveTo(pos.x + topleft.x, pos.y + topleft.y);
	//			ctx.lineTo(pos.x + bottomright.x, pos.y + topleft.y);
	//			ctx.lineTo(pos.x + bottomright.x, pos.y + bottomright.y);
	//			ctx.lineTo(pos.x + topleft.x, pos.y + bottomright.y);
	//			ctx.lineTo(pos.x + topleft.x, pos.y + topleft.y);
	//			ctx.strokeStyle="darkred";
	//			ctx.stroke();
			}
		}
	}
}

SysCollisions = function()
{
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Position && e.components.Visible && e.components.Collide)
			{
				var topleft = e.components.Visible.Topleft;
				var bottomright = e.components.Visible.Bottomright;
				var pos = e.components.Position.Position;

				for ( var layer2 = 0; layer2 <= LAYER_LAST_LAYER; layer2 == 0 ? layer2 = 1 : layer2 = layer2 << 1)
				{
					if ( layer2 & e.components.Collide.Collisionlayers )
					{
						for ( var eIdx2=entities[layer2].length-1; eIdx2 >= 0; eIdx2--)
						{
							var e2 = entities[layer2].data[eIdx2];
							if (e2 && e2.components.Position && e2.components.Visible && e2.components.Collide ) 
							{
								var topleft2 = e2.components.Visible.Topleft;
								var bottomright2 = e2.components.Visible.Bottomright;
								var pos2 = e2.components.Position.Position;
								// see if this other entity has collided with us
								// Note this is all terribly inneficient but is 
								// ok for a small amount of sprites

								if ( pos.x + topleft.x < pos2.x + bottomright2.x
									&& pos.x + bottomright.x > pos2.x + topleft2.x
									&& pos.y + topleft.x < pos2.y + bottomright2.y
									&& pos.y + bottomright.y > pos2.y + topleft2.y)
								{
									e.components.Collide.Collided = true;
								}
							}
						}
					}
				}
			}
		}
	}
}

SysCamera = function()
{
	var cameraPosX;
	var cameraPosY;
	// find first camera entity with a position
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Camera && e.components.Position && e.components.Physics)
			{
				cameraPosX = e.components.Position.Position.x + e.components.Physics.Velocity.x * 50;
				cameraPosY = 0;
			}
		}
	}
	
	if ( cameraPosX == null)
		return;
		
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Gamepos && e.components.Position)
			{
				var pos = e.components.Position.Position;
				
				pos.x = pos.x - cameraPosX;
				pos.y = pos.y - cameraPosY;
			}
		}
	}
}

SysPhysics = function()
{
	var cameraPosX = 0;
	var cameraPosY = 0;
	// find first camera entity with a position
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Camera && e.components.Position)
			{
				cameraPosX = e.components.Position.Position.x;
				cameraPosY = e.components.Position.Position.y;
			}
		}
	}
	
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Position && e.components.Physics)
			{
				var pos = e.components.Position.Position;
				var physics = e.components.Physics;
				var vel = physics.Velocity;
				
				if ( e.components.Rotation )
				{
					var rotation = e.components.Rotation.Rotation;
					rotation += e.components.Rotation.Rotatespeed;
					e.components.Rotation.Rotation = rotation;
				}

				
				pos.x = pos.x + vel.x;
				pos.y = pos.y + vel.y;
				
				// Apply the drag
				vel.x *= physics.Drag;
				vel.y *= physics.Drag;

				// limit to max velocity
				if ( physics.Maxvelocity)
				{
					if (vel.Magnitude() > physics.Maxvelocity )
					{
						vel.SetMagnitude(physics.Maxvelocity);
					}
				}

				if (e.components.Screenwrap)
				{
					HandleScreenWrap(pos);
				}

				if (e.components.Screenbounce)
				{
					HandleScreenBounce(pos,vel);
				}
			}
		}
	}
	
	function HandleScreenWrap(pos)
	{
		if ( pos.x <= GAME_X_MIN )
			pos.x += GAME_WIDTH;

		if ( pos.x >= GAME_X_MAX-1 )
			pos.x -= GAME_WIDTH;

		if ( pos.y <= GAME_Y_MIN )
			pos.y += GAME_HEIGHT;

		if ( pos.y >= GAME_Y_MAX-1 )
			pos.y -= GAME_HEIGHT;
	}
	
	function HandleScreenBounce(pos, vel)
	{
		if ( pos.x <= GAME_X_MIN ) 
		{
			if ( vel.x < 0 )
			{
				vel.x = -vel.x;
			}
			pos.x = GAME_X_MIN;
		}

		if ( pos.x >= GAME_X_MAX-1 ) 
		{
			if ( vel.x > 0  )
			{
				vel.x = -vel.x;
			}
			pos.x = GAME_X_MAX-1;
		}

		if ( pos.y <= GAME_Y_MIN ) 
		{
			if ( vel.y < 0 )
			{
				vel.y = -vel.y;
			}
			pos.y = GAME_Y_MIN;
		}

		if ( pos.y >= GAME_Y_MAX-1 ) 
		{
			if ( vel.y > 0)
			{
				vel.y = -vel.y;
			}
			pos.y = GAME_Y_MAX-1;
		}
	}
}

SysEnemies = function()
{
	for ( var eIdx=entities[LAYER_ENEMY].length-1; eIdx >= 0; eIdx--)
	{
		var e = entities[LAYER_ENEMY].data[eIdx];
		if (e && ( e.components.EnemyA || e.components.EnemyB || e.components.EnemyTeamMember) )
		{
			CheckCollided(e);
		}

		if ( e.components.Spawner)
		{
			var spawner = e.components.Spawner;
			spawner.ElapsedTime++;
			if ( prefabs.Count(spawner.SpawnPrefabType) <= spawner.SpawnMax)
			{
				if ( spawner.ElapsedTime > spawner.SpawnRate)
				{
					var xpos = 0;
					var ypos = 0;
					if (e.components.Position)
					{
						xpos = e.components.Position.Position.x;
						ypos = e.components.Position.Position.y;
					}
					spawner.ElapsedTime = 0;
					if ( spawner.SpawnPrefabType == "EnemyA")
						prefabs.CreateEnemyA(xpos,ypos);
					if ( spawner.SpawnPrefabType == "EnemyB")
						prefabs.CreateEnemyB(xpos,ypos);
					if ( spawner.SpawnPrefabType == "SwarmA")
						prefabs.CreateSwarmA(xpos,ypos);
				}
			}
		}
		
		if ( e.components.EnemyTeamLeader)
		{
			if ( e.components.EnemyTeamLeader.TeamMembers.length == 0)
			{
				e.components.Collide.Destroy = true;
			}
			
			e.components.Position.Position.y += Math.cos(e.components.EnemyTeamLeader.YPosAngleOffset)*4;
			e.components.EnemyTeamLeader.YPosAngleOffset += Math.PI/50;
			// Set the world positions of the members
			// relate to our position
			var memberDied = false;
			for ( var mIdx = e.components.EnemyTeamLeader.TeamMembers.length - 1; mIdx >= 0; mIdx--)
			{
				var m = e.components.EnemyTeamLeader.TeamMembers.data[mIdx];
				if ( m.components.Collide.Destroy )
				{
					e.components.EnemyTeamLeader.TeamMembers.Delete(mIdx);
					memberDied = true;
					if ( e.components.EnemyTeamLeader.TeamMembers.length == 0 )
					{
						prefabs.CreatePowerUp(m.components.Position.Position.x,m.components.Position.Position.y,0,0);
					}
				}
				else
				{
					if ( m.components.EnemyTeamMember.Position.x < m.components.EnemyTeamMember.DesiredPosition.x)
						m.components.EnemyTeamMember.Position.x++;
					else
						m.components.EnemyTeamMember.Position.x--;
					if ( m.components.EnemyTeamMember.Position.y < m.components.EnemyTeamMember.DesiredPosition.y)
						m.components.EnemyTeamMember.Position.y++;
					else
						m.components.EnemyTeamMember.Position.y--;	
					m.components.Position.Position.x = m.components.EnemyTeamMember.Position.x + e.components.Position.Position.x;
					m.components.Position.Position.y = m.components.EnemyTeamMember.Position.y + e.components.Position.Position.y;
				}
			}
			if ( memberDied && e.components.EnemyTeamLeader.TeamMembers.length != 0)
			{
				// At least 1 team member died so recalculate desired positions
				var swarmSize = e.components.EnemyTeamLeader.TeamMembers.length;
				for ( var mIdx = e.components.EnemyTeamLeader.TeamMembers.length - 1; mIdx >= 0; mIdx--)
				{
					var m = e.components.EnemyTeamLeader.TeamMembers.data[mIdx];

					m.components.EnemyTeamMember.DesiredPosition.y = (mIdx - (swarmSize / 2)) * 30;
					m.components.EnemyTeamMember.DesiredPosition.x = Math.abs(mIdx - (swarmSize / 2)) * 30;
				}

			}
		}
		
	}
	
	// find the player
	var playerEntity = null;
	for ( var eIdx=0; eIdx < entities[LAYER_PLAYER].length; eIdx++)
	{
		var e = entities[LAYER_PLAYER].data[eIdx];
		if (e && e.components.Player && e.components.Position )
		{
			playerEntity = e;
			break;
		}
	}
	
	// drift the powerup towards the player
	for ( var eIdx=entities[LAYER_POWER_UP].length-1; eIdx >= 0; eIdx--)
	{
		var e = entities[LAYER_POWER_UP].data[eIdx];
		if ( e.components.PowerUp && e.components.Position && e.components.Physics )
		{
			// very basic just move towards player slowly
			if ( e.components.Physics && playerEntity )
			{
				var physics = e.components.Physics;
				var vel = physics.Velocity;
				
				var playerPos = playerEntity.components.Position.Position;
				var enemyPos = e.components.Position.Position;
				
				var xlen = playerPos.x - enemyPos.x;
				var ylen = playerPos.y - enemyPos.y;
				var vec = Vector(xlen,ylen);
				
				var distance = vec.Magnitude();
				
				if ( distance < 300)
				{
					var accel = (300-distance) / 150;
					accel *= accel;
					vec.SetMagnitude(accel);

					vel.x += vec.x;
					vel.y += vec.y;
//					vel.Add(vec);
				}
				
//				if ( playerPos.x < enemyPos.x )
//					vel.x = -.5;
//				if ( playerPos.x > enemyPos.x )
//					vel.x = .5;
//				if ( playerPos.y < enemyPos.y )
//					vel.y = -.5;
//				if ( playerPos.y > enemyPos.y )
//					vel.y = .5;
			}
		}

		if (e && e.components.PowerUp && e.components.Collide && e.components.Collide.Destroy == false)
		{
			if ( e.components.Collide.Collided)
			{
				e.components.Collide.Destroy = true;
				PlaySound(SOUND_POWERUP);
			}
		}
	}

	function CheckCollided ( e)
	{
		if ( e.components.Collide)
		{
			if ( e.components.Collide.Collided)
			{
				e.components.Collide.Destroy = true;
				if ( e.components.Position && e.components.Visible)
					CreateExplosion(e.components.Position.Position, e.components.Visible.Colour);
				if ( e.components.Position && !e.components.EnemyTeamMember )
					prefabs.CreatePowerUp(e.components.Position.Position.x,e.components.Position.Position.y,0,0);
				PlaySound(SOUND_ENEMY_EXPLODE);
			}
		}
	}
	
	function CreateExplosion(pos, colour)
	{
		for ( var p = 0; p < 50; p++)
		{
			var angle = Math.random() * Math.PI * 2;
			var speed = Math.random() * .5 + 1.5;
			var xvel = speed * Math.sin(angle);
			var yvel = speed * Math.cos(angle);
		
//			prefabs.CreateParticle(pos.x,pos.y,(Math.random()-.5)*2,(Math.random()-.5)*2,colour);
			prefabs.CreateParticle(pos.x,pos.y,xvel,yvel,colour);
		}
	}
}

SysPlayer = function()
{
	function CallectPowerUps(component)
	{
		if ( component && component.Collided)
		{
//				console.log("powerup");
			component.Collided = false;
		}
	}

	ProcessPlayers();
	ProcessShots();
	
	function ProcessPlayers()
	{
		for ( var eIdx=0; eIdx < entities[LAYER_PLAYER].length; eIdx++)
		{
			var e = entities[LAYER_PLAYER].data[eIdx];
			if (e && e.components.Player && e.components.Position && e.components.Physics && e.components.Rotation)
			{
				var pos = e.components.Position.Position;
				var rotation = e.components.Rotation.Rotation;
				var physics = e.components.Physics;
				var player = e.components.Player;

				CallectPowerUps(e.components.Collide);
				
				if (keystate[player.KeyRight])
				{
					rotation += player.Rotaterate; //physics.Rotatespeed;
				}
				if (keystate[player.KeyLeft])
				{
					rotation -= player.Rotaterate; //physics.Rotatespeed;
				}

				if (keystate[player.KeyAccelerate])
				{
					// covert the rotation angle to a vector
					var accel = Vector ( Math.cos(rotation), Math.sin(rotation));
					var xp = accel.x;
					var yp = accel.y;
					accel.SetMagnitude(physics.Acceleration);
					// Add the vector to the current acceleration vector
					physics.Velocity = physics.Velocity.Add(accel);

					prefabs.CreateParticle(pos.x - xp*20,pos.y - yp*20,-Math.random()*xp*4,-Math.random()*yp*4,"White");
				}

				player.ShotElapsedTime++;
				if ( keystate[player.KeyShoot] && player.ShotElapsedTime >= player.ShotRate)
				{
					var direction = Vector ( Math.cos(rotation), Math.sin(rotation));
					var shotpos = Vector(pos.x + direction.x * 10, pos.y + direction.y * 10);
					direction.SetMagnitude(12);
					CreateShot(shotpos, direction, rotation);
					player.ShotElapsedTime = 0;
					PlaySound(SOUND_SHOT);
				}
				
				e.components.Rotation.Rotation = rotation;
			}
		}
	}
	
	function ProcessShots()
	{
		for ( var eIdx=entities[LAYER_PLAYER_SHOT].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[LAYER_PLAYER_SHOT].data[eIdx];
			if (e && e.components.PlayerShot && e.components.Collide ) 
			{
				if ( e.components.Collide.Collided)
				{
					e.components.Collide.Destroy = true;
				}
			}		
		}
	}
	
	function CreateShot(pos,velocity, rotate)
	{
		prefabs.CreatePlayerShot(pos.x,pos.y,velocity.x,velocity.y, rotate)
	}
}

SysDestroyer = function()
{
	for ( var layer = 0; layer <= LAYER_LAST_LAYER; layer == 0 ? layer = 1 : layer = layer << 1)
	{
		for ( var eIdx=entities[layer].length-1; eIdx >= 0; eIdx--)
		{
			var e = entities[layer].data[eIdx];
			if (e && e.components.Lifespan )
			{
				e.components.Lifespan.Age+= 1;
				if ( e.components.Lifespan.Age >= e.components.Lifespan.MaxAge)
				{
					if ( e.components.Prefab )
					{
						prefabs.Delete(e.components.Prefab.Type, e.components.Prefab.Position)
					}
					entities[layer].Delete(eIdx);
				}
			}
			if (e && e.components.Collide)
			{
				if ( e.components.Collide.Destroy)
				{
					if ( e.components.Prefab )
					{
						prefabs.Delete(e.components.Prefab.Type, e.components.Prefab.Position);
					}
					entities[layer].Delete(eIdx);
				}
			}
		}
	}
}

Vector = function(x,y)
{
	var obj = {};
	
	obj.x = x;
	obj.y = y;

	obj.Add = function(v1)
	{
		return Vector(obj.x+v1.x, obj.y+v1.y);
	}

	obj.Subtract = function(v1)
	{
		return Vector(obj.x-v1.x, obj.y-v1.y);
	}

	obj.Multiply = function(v1)
	{
		return Vector(obj.x*v1.x, obj.y*v1.y);
	}

	obj.Magnitude = function()
	{
		return Math.sqrt(obj.x*obj.x + obj.y*obj.y);
	}

	obj.Normalise = function()
	{
		var mag = obj.Magnitude();
		obj.x /= mag;
		obj.y /= mag;
	}

	obj.SetMagnitude = function(newMagnitude)
	{
		obj.Normalise();
		obj.x *= newMagnitude;
		obj.y *= newMagnitude;
	}

	obj.DotProduct = function(v)
	{
		return obj.x * v.x + obj.y * v.y;
	}

	obj.ScalarMultiply = function(scalar)
	{
		obj.x *= scalar;
		obj.y *= scalar;
	}

	return obj;
}

BuildSounds = function ()
{
	audio[0] = CreateSound(2000,200,0,500,.5,0,.5,.15);
	audio[1] = CreateSound(7000,4000,0,0,1,0,0.25,.125);
	audio[2] = CreateSound(250,150,500,80,1,0,2,2);
}

CreateSound = function ( startFreq, endFreq, noiseFreq, noiseFreqAdj, startVol, endVol, duration, freqDuration)
{
	var noiseFreq = QBSynthJS.InputMultiplier(
		QBSynthJS.InputOscilatorRandom(QBSynthJS.InputBasic(noiseFreq),0), 
		QBSynthJS.InputBasic(noiseFreqAdj));

	var freqShiftAndNoise = QBSynthJS.InputAdd(
		QBSynthJS.InputLinearRepeat(startFreq,endFreq,QBSynthJS.InputBasic(1/freqDuration)), 
		noiseFreq);
	
	var volume = QBSynthJS.InputLinearRepeat(startVol,endVol,QBSynthJS.InputBasic(1/duration));

	var osc = QBSynthJS.InputMultiplier(
		QBSynthJS.InputOscilatorSquare(freqShiftAndNoise,0), 
		volume)
	
	output = QBSynthJS.GenerateData(8000, duration, osc);
	var wav = QBSound.BuildWavData(output,8000,0);
	return QBSound.CreateAudioObject(wav);
}

PlaySound = function(i)
{
	var a=audio[i];
	a.pause();
	a.currentTime=0;
	a.play().catch(function(e) { console.log("whoops.. cant play right now");});
}

var QBSynthJS = new function()
{
	var _this = this;

	this.InputBasic = function (value)
	{
	  var obj = {};
	  obj.GetValue = function(timeSpan)
	  {
	    return value;
	  }
	  return obj;
	}

	this.InputLinearRepeat = function(startValue, endValue,frequency)
	{
	  var obj = {};
	  var totalTime = 0;
	  var duration = 1/frequency.GetValue(0);
	  obj.GetValue = function(timeSpan)
	  {
	  	var newDuration = 1/frequency.GetValue(timeSpan); 
	  	totalTime += timeSpan;
	  	while ( totalTime >= duration)
	  	{
			totalTime -= duration;
			duration = newDuration;
	  	}
	    return startValue + (endValue - startValue) / duration * totalTime;
	  }
	  return obj;
	}

	this.InputMultiplier = function(input1, input2)
	{
	  var obj = {};
	  obj.GetValue = function(timeSpan)
	  {
	    return input1.GetValue(timeSpan) * input2.GetValue(timeSpan);
	  }
	  return obj;
	}

	this.InputAdd = function(input1, input2)
	{
	  var obj = {};
	  obj.GetValue = function(timeSpan)
	  {
	    return input1.GetValue(timeSpan) + input2.GetValue(timeSpan);
	  }
	  return obj;
	}

	this.InputOscilatorSquare = function(frequency, startAngle)
	{
		var obj = {};
		var angle = 0;

		if ( startAngle !== undefined)
			angle = startAngle;

		obj.GetValue = function(timeSpan)
		{
			var angleInc = timeSpan * frequency.GetValue(timeSpan) * (Math.PI * 2);

			angle += angleInc;
			if ( angle >= Math.PI * 2)
			  angle -= Math.PI * 2;

		    var value = Math.sin(angle);
		    if ( value >= 0)
		     	return 1
		    else
		     	return -1;
		};
		return obj;
	}

	this.InputOscilatorRandom = function(frequency, startAngle)
	{
	 	var obj = {};
	  	var angle = 0;
		var value = (Math.random()*2) - 1;

		if ( startAngle !== undefined)
	   		angle = startAngle;

		obj.GetValue = function(timeSpan)
		{
			var angleInc = timeSpan * frequency.GetValue(timeSpan) * (Math.PI * 2);

			angle += angleInc;
			if ( angle > Math.PI * 2)
			{
			  angle -= Math.PI * 2;
			  value = (Math.random()*2) - 1;
			}
	    	return value;
	  	};
		return obj;
	}

	this.GenerateData = function(bitrate, duration, osc)
	{
	  var values = [];
	  var valueSize = 1;
	  var inc = 1/bitrate;

	  values[0] = osc.GetValue(0);
	  for ( var x = inc; x <= duration;x = x + inc)
	  {
	    var value = osc.GetValue(inc);

	    values[valueSize++] = value;
	  }

	  return values;
	}
}

var QBSound = new function()
{
	function insertLong(inString, index, inValue)
	{
		var retString = inString.substr(0,index);
		for (i = 0; i < 4; ++i) {
		  retString += String.fromCharCode(inValue & 255);
		  inValue = inValue >> 8;
		}
		retString += inString.substr(index+4);
		return retString;
	}

	this.BuildWavData = function (values,bitrate,channel)
	{
		var n = values.length;
		var wavData = "RIFF****WAVEfmt \x10\x00\x00\x00\x01\x00\x01\x00********\x01\x00\x08\x00data****";

		// ChunkSize
		var numval = n + 36;
		wavData=insertLong(wavData,4,numval);

		numval = bitrate; // byterate
		wavData = insertLong(wavData,24,numval);
	 
		  // BitRate
		numval = bitrate * 8; //44100;
		wavData = insertLong(wavData,28,numval);
	 
		  // Subchunk2Size
	//      insertLong(n);
		numval = n;
		wavData = insertLong(wavData,40,numval);
		  
		// Output sound data
		for (var i = 0; i < n; ++i)
		{
			var charCode = Math.round(Math.min(127, Math.max(-127, values[i]*127))+127);
			wavData += String.fromCharCode(charCode);
		}
		
		return wavData		
	}

	this.CreateAudioObject = function (wavData)
	{
		var encoded = btoa(wavData);
		src = 'data:audio/wav;base64,' + encoded;
		var a = new Audio();
		a.src = src;
		return a;
	}
}

function PrefabManager()
{
	var obj = {};
	
	var collections = new Array();
	for ( var c = 0; c <= PREFAB_LAST; c++ )
	{
		collections[c] = QuickCollection();
	}
	
	var players = collections[PREFAB_PLAYERS];
	var particles = collections[PREFAB_PARTICLES];
	var playerShots = collections[PREFAB_PLAYERSHOTS];
	var EnemyA = collections[PREFAB_ENEMYA];
	var EnemyB = collections[PREFAB_ENEMYB];
	var PowerUps = collections[PREFAB_POWERUPS];
	var RadarHud = collections[PREFAB_RADARHUD];
	var Spawner = collections[PREFAB_SPAWNER];
	var SwarmALeader = collections[PREFAB_SWARMLEADER];
	var SwarmAMember = collections[PREFAB_SWARMMEMBER];

	obj.Count = function(type)
	{
		if ( type == "EnemyA")
			return EnemyA.length;
		if ( type == "EnemyB")
			return EnemyB.length;
		if ( type == "SwarmA")
			return SwarmAMember.length;
	}
	
	obj.CreatePlayer = function (keyleft, keyright, keyaccelerate, keyshoot)
	{
		var entity = players.Reclaim();
		if ( entity == null )
		{
			entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics()); 
			entity.AddComponent(CompVisible(shipData,"White",LAYER_PLAYER));
			entity.AddComponent(CompPlayer());
			
			entity.AddComponent(CompScreenBounce());
			entity.AddComponent(CompCollide(LAYER_POWER_UP));
			entity.AddComponent(CompPrefab(PREFAB_PLAYERS));
			entity.AddComponent(CompCamera());
			entity.AddComponent(CompGamePos());
			entity.AddComponent(CompRadar());
			entity.AddComponent(CompRotation());
		}
		
		ec = entity.components.Prefab;
//		ec.Type = "Player";
		ec.Position = players.length;
		

		var ec = entity.components.Position;
		ec.Position.x = 0;
		ec.Position.y = 0;

		var ec = entity.components.Rotation;
		ec.Rotation = 0;

		ec = entity.components.Physics
		ec.Velocity.x = 0;
		ec.Velocity.y = 0;
		ec.Acceleration = .1;
		ec.Drag = .99;
//		ec.Rotatespeed = Math.PI/50;
		ec.Maxvelocity = 8;

//		ec = entity.components.Visible;
//		ec.Drawdata = shipData;
//		ec.DrawdataTransformed = shipData;
//		ec.Colour = "White";
//		ec.Layer = LAYER_PLAYER;

		ec = entity.components.Player;
		ec.KeyLeft = keyleft;
		ec.KeyRight = keyright;
		ec.KeyAccelerate = keyaccelerate;
		ec.KeyShoot = keyshoot;
		
		entities[LAYER_PLAYER].Insert(entity);
		
		return entity;	
	}
	
	obj.CreateParticle = function (xpos, ypos, xvel, yvel, colour)
	{
		var entity = particles.Reclaim();
		if ( entity == null )
		{
			entity = Entity();
			var colour = colour;
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompLifeSpan());
			entity.AddComponent(CompVisible(explosionData,colour,0));
			entity.AddComponent(CompPrefab(PREFAB_PARTICLES));
			entity.AddComponent(CompGamePos());
			
			console.log("Creating particle");
		}

		ec = entity.components.Prefab;
//		ec.Type = "Particle";
		ec.Position = particles.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;
		ec.Rotation = 0;

		ec = entity.components.Physics
		ec.Velocity.x = xvel;
		ec.Velocity.y = yvel;
		ec.Acceleration = 1;
		ec.Drag = 1;

		ec = entity.components.Visible;
//		ec.Drawdata = explosionData;
		ec.Colour = colour;
//		ec.Layer = 0;

		ec = entity.components.Lifespan;
		ec.MaxAge = 50 + Math.floor(Math.random() * 20);
		ec.Age = 0;

		particles.Insert(entity);
		entities[0].Insert(entity);
		
		return entity;
	}
	
	obj.CreateEnemyA = function ( xpos, ypos)
	{
		var entity = EnemyA.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			var colour = "Yellow";

			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompScreenWrap());
			entity.AddComponent(CompEnemyA());

			entity.AddComponent(CompCollide(LAYER_PLAYER | LAYER_PLAYER_SHOT));
			entity.AddComponent(CompVisible(enemyData,colour,LAYER_ENEMY));
			entity.AddComponent(CompPrefab(PREFAB_ENEMYA));
			entity.AddComponent(CompGamePos());
			entity.AddComponent(CompRadar());
			entity.AddComponent(CompRotation());
		}

		ec = entity.components.Prefab;
		ec.Position = EnemyA.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

		var ec = entity.components.Rotation;
		ec.Rotation = 0;
		ec.Rotatespeed = Math.PI/25;
		
		ec = entity.components.Collide
		ec.Collided = false;
		ec.Destroy = false;

		ec = entity.components.Physics
		ec.Velocity.x = (Math.random()-.5)*4;
		ec.Velocity.y = (Math.random()-.5)*4;
		ec.Acceleration = 1;
		ec.Drag = 1;

//		ec = entity.components.Visible;
//		ec.Drawdata = enemyData;
//		ec.Colour = "Yellow";
//		ec.Layer = LAYER_ENEMY;

		EnemyA.Insert(entity);
		entities[LAYER_ENEMY].Insert(entity);

		return entity;
	}

	obj.CreateEnemyB = function ( xpos, ypos)
	{
		var entity = EnemyB.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			var colour = "Cyan";

			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompScreenBounce());
			entity.AddComponent(CompEnemyB());
			
			entity.AddComponent(CompCollide(LAYER_PLAYER | LAYER_PLAYER_SHOT));
			entity.AddComponent(CompVisible(enemyData,colour,LAYER_ENEMY));
			entity.AddComponent(CompPrefab(PREFAB_ENEMYB));
			entity.AddComponent(CompRadar());
		}

		ec = entity.components.Prefab;
		ec.Position = EnemyB.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

//		var ec = entity.components.Rotation;
//		ec.Rotation = 0;
		
		ec = entity.components.Collide
		ec.Collided = false;
		ec.Destroy = false;

		ec = entity.components.Physics
		ec.Velocity.x = (Math.random()-.5)*4;
		ec.Velocity.y = (Math.random()-.5)*4;
		ec.Acceleration = 1;
		ec.Drag = 1;

//		ec = entity.components.Visible;
//		ec.Drawdata = enemyData;
//		ec.Colour = "Green";
//		ec.Layer = LAYER_ENEMY;

		EnemyB.Insert(entity);
		entities[LAYER_ENEMY].Insert(entity);

		return entity;
	}
	
	obj.CreateSwarmA = function ( xpos, ypos)
	{
		var entity = SwarmALeader.Reclaim();
		if ( entity == null )
		{
			entity = Entity();
			var colour = "Pink";

			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompScreenWrap());
			entity.AddComponent(CompEnemyTeamLeader());
			entity.AddComponent(CompGamePos());

			entity.AddComponent(CompCollide());
//			entity.AddComponent(CompVisible(powerUpData,colour,LAYER_ENEMY));
			entity.AddComponent(CompPrefab(PREFAB_SWARMLEADER));
			entity.AddComponent(CompRadar());
		}

		ec = entity.components.Prefab;
		ec.Position = SwarmALeader.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

//		var ec = entity.components.Rotation;
//		ec.Rotation = 0;
		
		ec = entity.components.Collide
		ec.Collided = false;
		ec.Destroy = false;

		var velocityDirection = 1;
		if ( Math.random() > .5 )
			velocityDirection = -1;
		
		ec = entity.components.Physics
		ec.Velocity.x = 4 * velocityDirection;
		ec.Velocity.y = 0;
		ec.Acceleration = 1;
		ec.Drag = 1;

		SwarmALeader.Insert(entity);
		entities[LAYER_ENEMY].Insert(entity);

		// Now build the swarm members
		// Should I be doing this here ?
		// It feels wrong but I dont know where this should happen

		// A vertical line of the enemies
		var swarmSize = 11;
		for ( var e = 0; e < swarmSize; e++ )
		{
			var entity2 = SwarmAMember.Reclaim();
			if ( entity2 == null )
			{
				entity2 = Entity();
				var colour = "Orange";

				entity2.AddComponent(CompPosition());
				entity2.AddComponent(CompPhysics());
				entity2.AddComponent(CompScreenWrap());
				entity2.AddComponent(CompEnemyTeamMember());
				
				entity2.AddComponent(CompCollide(LAYER_PLAYER | LAYER_PLAYER_SHOT));
				entity2.AddComponent(CompVisible(enemyData,colour,LAYER_ENEMY));
				entity2.AddComponent(CompPrefab(PREFAB_SWARMMEMBER));
				entity2.AddComponent(CompRadar());
			}

			ec = entity2.components.Prefab;
			ec.Position = SwarmAMember.length;
			
			var ec = entity2.components.Position;
			ec.Position.x = xpos;
			ec.Position.y = ypos;

	//		var ec = entity.components.Rotation;
	//		ec.Rotation = 0;
			
			ec = entity2.components.Collide
			ec.Collided = false;
			ec.Destroy = false;

			ec = entity2.components.Physics
			ec.Velocity.x = 0;
			ec.Velocity.y = 0;
			ec.Acceleration = 1;
			ec.Drag = 1;
			
			ec = entity2.components.EnemyTeamMember
//			var xp = e * 10;
//			if ( e > Math.floor(swarmSize/2) )
//			{
//				xp = (swarmSize-e-1) * 10;
//			}
//			ec.Position.x = xp * velocityDirection;
//			ec.Position.y = ypos + (e-2.5) * 35;
ec.Position.x = 0;
ec.Position.y = 0;
//ec.Position.y = (e - (swarmSize / 2)) * 30;
ec.DesiredPosition.x = Math.abs(e - (swarmSize / 2)) * 30;;
ec.DesiredPosition.y = (e - (swarmSize / 2)) * 30;
			
			entity2.components.EnemyTeamMember.TeamLeader = entity;
			
			entity.components.EnemyTeamLeader.TeamMembers.Insert(entity2);
			
			SwarmAMember.Insert(entity2);
			entities[LAYER_ENEMY].Insert(entity2);
		}
		
		return entity;
	}
	
	obj.CreatePlayerShot = function (xpos,ypos,xvel,yvel, rotation)
	{
		var entity = playerShots.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompLifeSpan());
			entity.AddComponent(CompVisible(playerShotData,"White",LAYER_PLAYER_SHOT));
			entity.AddComponent(CompCollide(LAYER_ENEMY));
			entity.AddComponent(CompPlayerShot());
			entity.AddComponent(CompPrefab(PREFAB_PLAYERSHOTS));
//			entity.AddComponent(CompGamePos());
			entity.AddComponent(CompRotation());

			console.log("Creating playershot");
		}

		ec = entity.components.Prefab;
		ec.Position = playerShots.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

		var ec = entity.components.Rotation;
		ec.Rotation = rotation;

		ec = entity.components.Physics
		ec.Velocity.x = xvel;
		ec.Velocity.y = yvel;
		ec.Acceleration = 0;
		ec.Drag = 1;

		var ec = entity.components.Lifespan;
		ec.MaxAge = 50;
		ec.Age = 0;

//		ec = entity.components.Visible;
//		ec.Drawdata = playerShotData;
//		ec.Colour = "White";
//		ec.Layer = LAYER_PLAYER_SHOT;

		ec = entity.components.Collide
		ec.Collided = false;
		ec.Destroy = false;
		
		playerShots.Insert(entity);
		entities[LAYER_PLAYER_SHOT].Insert(entity);
		
		return entity;
	}
	
	obj.CreatePowerUp = function (xpos,ypos,xvel,yvel)
	{
		var entity = PowerUps.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompPhysics());
			entity.AddComponent(CompLifeSpan());
			entity.AddComponent(CompVisible(powerUpData,"Cyan",LAYER_POWER_UP));
			entity.AddComponent(CompCollide(LAYER_PLAYER));
			entity.AddComponent(CompPowerUp());
			entity.AddComponent(CompPrefab(PREFAB_POWERUPS));
			entity.AddComponent(CompGamePos());
			entity.AddComponent(CompRotation());
		}

		ec = entity.components.Prefab;
		ec.Position = PowerUps.length;
		
		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

		var ec = entity.components.Rotation;
		ec.Rotation = 0;
		ec.Rotatespeed = -Math.PI / 50;

		ec = entity.components.Physics
		ec.Velocity.x = xvel;
		ec.Velocity.y = yvel;
		ec.Acceleration = 0;
		ec.Drag = .7;


		var ec = entity.components.Lifespan;
		ec.MaxAge = 600;
		ec.Age = 0;

		ec = entity.components.Collide
		ec.Collided = false;
		ec.Destroy = false;
		
		PowerUps.Insert(entity);
		entities[LAYER_POWER_UP].Insert(entity);
		
		return entity;
	}
	
	obj.CreateRadarHud = function()
	{
		var entity = playerShots.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompVisible(radarBorderData,"White",LAYER_HUD));
			entity.AddComponent(CompPrefab(PREFAB_RADARHUD));
		}

		var ec = entity.components.Position;
		ec.Position.x = 0;
		ec.Position.y = -SCREEN_HEIGHT/2 + GAME_HEIGHT/20 + 2;
		ec = entity.components.Visible;
//		ec.Drawdata = radarBorderData;
//		ec.Colour = "White";
//		ec.Layer = LAYER_HUD;

		RadarHud.Insert(entity);
		entities[LAYER_HUD].Insert(entity);

		return entity;
	}

	obj.CreateSpawner = function( xpos, ypos, spawnRate, prefabType, spawnMax)
	{
		var entity = Spawner.Reclaim();
		if ( entity == null )
		{
			var entity = Entity();
			entity.AddComponent(CompPosition());
			entity.AddComponent(CompSpawner());
			entity.AddComponent(CompPrefab(PREFAB_SPAWNER));
		}

		var ec = entity.components.Position;
		ec.Position.x = xpos;
		ec.Position.y = ypos;

		var ec = entity.components.Spawner;
		ec.SpawnRate = spawnRate;
		ec.ElapsedTime = 0;
		ec.SpawnPrefabType = prefabType;
		ec.SpawnMax = spawnMax;

		Spawner.Insert(entity);
		entities[LAYER_ENEMY].Insert(entity);

		return entity;
	}
	
	obj.Delete = function(type, position)
	{
		var collection = collections[type];
		//
		// Special logic for swarms.
		// If a swarm member is destroyed 
		// then remove the member from the swarm leader internal list
//		var en = collection.data[position];
//		if ( en.components.EnemyTeamMember)
//		{
//			var enl = en.components.EnemyTeamMember.TeamLeader;
//			for ( var e = 0; e < enl.components.EnemyTeamLeader.TeamMembers.length; e++)
//			{
//				if ( enl.components.EnemyTeamLeader.TeamMembers.data[e] === en)
//				{
//					enl.components.EnemyTeamLeader.TeamMembers.Delete[e];
//				}
//			}
//		}

		if ( collection.length > 1)
		{
//			// Bit of a Hack
//			// we need to repoint the last entity prefab entry to contain the position
//			// of the one we are deleting ( as that is where it will end up after the delete )
			collection.data[collection.length-1].components.Prefab.Position = position;
		}
		collection.Delete(position);
	}
	
	return obj;
}

function QuickCollection()
{
	var obj = {};
	obj.length = 0;
	obj.data = new Array();
	
	obj.Insert = function(item)
	{
		// if the item had been reclaimed then the item is already in the array
		if ( obj.data[obj.length] != item )
		{
			obj.data[obj.length] = item;
			console.log("added item to quicklist");
		}
		
		obj.length++;
	}
	
	// This function will return the first object in the list
	// that is now "deleted".
	obj.Reclaim = function()
	{
		if ( obj.length <= obj.data.length)
		{
			return obj.data[obj.length]
		}
		return null;
	}
	
	obj.Delete = function(pos)
	{
		if ( pos > obj.length - 1)
			return;
			
		if ( pos == obj.length - 1)
		{
			obj.length--;
		}
		else
		{
			// swap with the last item in the collection
			var temp = obj.data[pos];
			obj.data[pos] = obj.data[obj.length-1];
			obj.data[obj.length-1] = temp;
			obj.length--;
		}
	}
	
	return obj;
}

// last piece of code is to start the game
init();
</script>
</body>
</html>